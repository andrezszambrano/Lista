El trabajo adjuntado tiene como objetivo, servir a programadores interesados en la utilización de TDA listas como método eficiente de guardado de información. 
Para usarlo, el usuario solo tiene poner en la cabecera de su .c #include "lista.h", descargar la biblioteca, y compilar usando la siguiente línea: "gcc -g /ruta/a/biblioteca.c /ruta/a/archivo/propio.c -Wall -Wextra -o ejecutable". Qué sencillo, ¿no? Ya tenes el poder de guardar cualquier información eficientemente, y también de una manera elegante, sí me dejan agregar. Ejecutalo, haciendo "./ejecutable", y nadie te va a poder parar.  
El TDA está implementado de tal forma, que ciertas operaciones puedan ser rápidamente ejecutadas, sin importar el número de elementos, por lo que no se siguió un tipo de dato abstracto con puntero a sí mismo, sino que se usa un sistema de nodos ajeno al usuario (éste no lo puede controlar), siendo este sistema los que apuntan a las nuevas listas que se van agregando. Ésta (no tan) sútil diferencia, hace que una operación como insertar después de la última lista (añadir una lista) sea independiente del número que hay de éstas. Muy impresionante, ¿no? Así, mientras el programa se está corriendo, y éste tiene listas agregadas, va a haber una lista "madre" que tiene un puntero al primer nodo. Éste nodo, a su vez, tiene dos punteros, uno a la segunda lista, y otro al siguiente nodo. Para el siguiente nodo pasa lo mismo, y así hasta que no haya más nodos siguientes, y el nodo siguiente del último nodo sea NULL. Ésto tiene una consecuencia un poco trivial, pero para un dado momento en donde el número de listas sea mayor o igual a 2, va a haber un número de nodos igual al número de listas menos uno. Se me olvidaba mencionar, que la lista madre también presenta un nodo que apunta al nodo final, para que la eficacia siempre esté presente en cualquier proceso ejecutado.
Entiendo como una lista a, un tipo de dato abstracto que almacena información genérica, y ésta puede ser implementada ya sea usando vectores estáticos, dinámicos, o, como en éste caso, punteros. La característica principal de este tipo de datos, es que el número de listas totales, así como sus posiciones, pueden ser modificados como uno plazca, algo que no pasa con el TDA cola o el TDA pila (¿querés saber más? seguí leyendo). Por lo tanto, en cualquier momento dado, sí tengo una lista con 10 elementos, puedo eliminar el 5to, el 2do, añadir en la posición 9, todo esto sin ningún tipo de inconveniencias. Seguro te preguntás cómo, pero tranquilo, solo tenés que saber qué es lo que está pasando, yo me encargo del resto. El tipo de dato lista tiene un sin fin de aplicaciones, ya sea manejar información como, qué comida compraste éste mes, series que querés ver, cosas pendientes que querés hacer, y un largo etc. ¿No te parece impresionante? sí no lo crees, seguro cambias de opinión cuando te diga que, además de visualizar y almacenar tus datos preferidos, podes hacer cálculos con estos, usando un iterador interno. ¿Querés que te diga más cosas? No, ya te toca usar la biblioteca por vos mismo y descubrir las posibilidades. No te sientas intimidado, ¡está todo bien explicado en las pre y post condiciones! Una lista simplemente enlazada, como es la de ésta biblioteca, es un TDA que se conecta entre ellos con punteros a las posiciones siguientes (proceso ya explicado con los nodos). Es la manera más simple de trabajar con punteros, pero por ésta razón ciertas operaciones siempre van a depender del número de listas que hay, que podría afectar la cantidad de tiempo en realizar los procesos, sobretodo cuando el número de listas es exageradamente elevado, ya que dado cualquier momento de ejecución, solo hay un puntero apuntando a un nodo arbitrario, por lo que para acceder a éste hay que recorrer toda la lista. Hay una solución a esto, no obstante, y es la utilización de una lista doblemente enlazada, esto es, listas que apuntan tanto a la lista siguiente como a la lista anterior. En este caso, cuando el programa está corriendo, una lista arbitraria está siendo apuntada tanto por su siguiente como por su anterior. Ésto es de especial utilidad para bajar considerablemente el tiempo de ejecución de ciertos procesos, cuando por ejemplo querés acceder a una lista que está cerca de la posición final. Ésta implementación, aunque de mucha utilidad, aumenta la complejidad del código, ya que hay que tener mucho cuidado con dónde apuntan los punteros, y no perder referencia de los que nos importan. 
En líneas anteriores se dio una idea de lo que podría ser un TDA pila o TDA cola, y no son nada más que un caso específico de un TDA lista. El TDA pila, se caracteriza por la frase Last In First Out (LIFO), o último que entró es el primero que sale, y no es nada más que eso: solo podes añadir y quitar datos al final de la pila. Además, tiene como característica la función mostrar tope, que devuelve el elemento que está en la posición última. El TDA cola, en otro lado, se define por la frase First In First Out (FIFO), o el primero que entró es el primero que sale, por lo que añadís elementos en la posición cero de la cola, y borrás de la última posición. Éste TDA también tiene su operación predeterminada, y es mostrar primero, que en realidad es mostrar el elemento de la última posición, ya que fue el primero que entró de los que se encuentran en la cola. Podrán parecer como TDA's innecesarios, pero para algunos casos no es muy útil tener toda la implementación de un TDA lista y alcanza con los procesos ya explicados. Te podrías preguntar, ¿qué pasa sí decido también añadir en una posición arbitraria, no necesariamente al final o al principio, dependiendo del TDA? pues nada, solamente dejaría de ser un TDA pila o TDA cola y sería un TDA lista. Lo importante es que, el usuario es bienvenido a usar los procesos que más se adapten a sus necesidades.
Un iterador es un TDA que apunta primeramente a la lista madre, pudiendo alterar el dato correspondiente, o avanzar a los nodos, recorriendo todas las listas disponibles. Añade ciertas funcionalidades, como mostrar por pantalla los datos apuntados, y revisar cuantos datos tiene la función. El iterador externo es manejado por el usuario, mientras que el interno está listo para ser usado por vos, solo mandando una función como puntero, ya sea una que muestre valores por pantalla, o que sume éstos, etc. Hay una excepción, y es que no me hago responsable de las inserciones o borradas que hagas, ya que hay posibilidades de que el iterador deje de ser útil (¡lee las pre y post condiciones!), ¡pero tranquilo!, destruís el iterador activo y create otro, que ese funciona perfecto.
Nada más qué decir, explorá las posibilidades y agradeceme después.   